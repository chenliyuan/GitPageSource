title: Python-GIL&进程线程
author: 躲不掉的风
date: 2020-02-03 18:27:32
tags:
---
##### GIL 全局解释器锁

GIL本质就是一把互斥锁，既然是互斥锁，所有互斥锁的本质都一样，都是将并发运行变成串行，以此来控制同一时间内共享数据只能被一个任务所修改，进而保证数据安全。

###### 实例：

  使用死循环程序while True:pass
    
  双核CPU:可用htop实时查看进程占用情况
  
-  单进程单线程执行1个线程   CPU1占满100%
- 单进程多线程执行两个线程   各占用50%（加起来是一个核）
- 使用多进程执行两个进程   各占满100%（每个进程真正占满一个核）

###### 结论：<font color=red>python中多线程是假的。只有多进程能实现并发</font>，每个进程占用一个CPU。

###### 原因：<font color=red>GIL</font>：使得多线程程序一个时刻只能有一个线程在使用。

为什么python有这个问题？

    实际不是python本身的问题，而是由于其解释器的限制：
    Python默认使用C-python解释器（其他版本比如Java版的python解释器就不会有这个问题,但是这个GIL问题不容易解决所以至今依旧如此）
    
    
所以python可使用多进程来实现多任务并发，替代多线程实现。

##### 多线程是否要比单线程快？

回答：是的。因为多线程会在适当的实际执行必要的操作，避免等待造成的时间消耗。增加效率。

##### 什么时候用进程什么时候用线程？

- 计算密集型程序：进程（可以发挥多核cpu的作用）

- io密集型程序：线程、协程（可以充分利用等待时间）